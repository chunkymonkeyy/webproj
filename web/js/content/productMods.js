var productMods = {}; // empty, globally defined obj

function MakeEditArea(params) {

    function makeInputRow(fieldDef) {

        var obj = {}; // this will hold references to the input box and the error td for the 
        // given field name.

        var row = Utils.make({// Inject a row into the table 
            htmlTag: "tr",
            parent: validationTable
        });
        Utils.make({// first td of row will hold promptText
            htmlTag: "td",
            innerHTML: fieldDef.prompt || fieldDef.fieldName, // use fieldName as prompt for now, later promptText,
            parent: row
        });
        obj.inputTd = Utils.make({// second td of row will hold user input
            htmlTag: "td",
            parent: row
        });

        if (fieldDef.pickList) {
            // If the field is a FK (select tag), do nothing. 
            // Let the calling code put in the select tag that they want.
        } else { // insert an input box, possibly make it disabled and/or set it to type="password"
            // store reference to this input box. we need to access it programatically 
            // (to find user's input).
            obj.inputBox = Utils.make({// place textbox in second td
                htmlTag: "input",
                parent: obj.inputTd
            });

            if (fieldDef.disabled) {
                obj.inputBox.setAttribute("disabled", true);
            }

            if (fieldDef.password) {
                obj.inputBox.setAttribute("type", "password");
            }
        }

        // store reference to the 3rd td that is for holding error messages, 
        // so we can access it programmatically.
        obj.errorTd = Utils.make({
            htmlTag: "td",
            parent: row,
            class: "error"
        });
        // obj has a reference to the inputBox and the errorTd (the two things 
        // we need to access programatically to do validation). Store this 
        // object into an associative array (using fieldName as key). 
        editArea[fieldDef.fieldName] = obj;
    } // makeInputRow


    // ****************************************************
    // ******* ENTRY POINT FOR MakeEditArea ***************

    // check parameter object, declare and initialize parameter variables.
    if (!params.fieldDefn || !params.fieldDefn[0]) {
        throw new Error("MakeEditArea requires a parameter object with property 'fieldDefn' - " +
                "an array of objects that define the fields for the Edit Area.");
        return;
    }
    var fieldDefn = params.fieldDefn;

    var editArea = document.createElement("div");
    editArea.classList.add("editArea");

    editArea.areaTitle = Utils.make({
        htmlTag: "h2",
        innerHTML: params.areaTitle || "Untitled",
        parent: editArea
    });

    var validationTable = Utils.make({
        htmlTag: "table",
        parent: editArea
    });

    // populate validationTable with rows. Each row has a column for field prompt, 
    // a column for input value, and a column for possible error message (generated by server). 
    for (var i = 0; i < fieldDefn.length; i++) {
        makeInputRow(fieldDefn[i]);
    }

    var lastRow = Utils.make({// Inject a row into the table 
        htmlTag: "tr",
        parent: validationTable
    });

    var firstCol = Utils.make({// Inject a row into the table 
        htmlTag: "td",
        parent: lastRow
    });

    editArea.button = Utils.make({// Inject a row into the table 
        htmlTag: "button",
        parent: firstCol
    });

    editArea.formMsg = Utils.make({// Inject a row into the table 
        htmlTag: "td",
        class: "error",
        parent: lastRow
    });

    editArea.formMsg.colSpan = 2; // form message spans two columns. 

    // create an object from the values typed into the page, then turn that object into JSON, 
    // URL encode it and return it.
    editArea.getDataFromUI = function () {

        var userInputObj = {};
        for (var i = 0; i < fieldDefn.length; i++) {
            var fieldName = fieldDefn[i].fieldName;

            // FK fields will have a select tag, not an inputBox. 
            // Let the calling code (that called MakeEditArea) put in the select tag values.
            if (editArea[fieldName].inputBox) {
                userInputObj[fieldName] = editArea[fieldName].inputBox.value;
            }
        }

        console.log("getDataFromUI - userInputObj on next line");
        console.log(userInputObj);

        return userInputObj;

    };

    // write the jsonObj (full of error messages) to the error message column of the 
    // HTML table in the editArea component.  
    editArea.writeErrorObjToUI = function (obj) {

        console.log("The error msg object from attempt to insert (see next line).");
        console.log(obj);

        for (var i = 0; i < fieldDefn.length; i++) {
            var fieldName = fieldDefn[i].fieldName;
            editArea[fieldName].errorTd.innerHTML = obj[fieldName];
        }

    }; // writeErrorObjToUI


    // write the jsonObj (full of error messages) to the error message column of the 
    // HTML table in the editArea component.  
    editArea.writeDbValuesToUI = function (obj) {

        console.log("The error msg object from attempt to insert (see next line).");
        console.log(obj);

        for (var i = 0; i < fieldDefn.length; i++) {
            var fieldName = fieldDefn[i].fieldName;

            // pickLists (FK fields) do not have an input box, so skip them.
            if (editArea[fieldName].inputBox) {
                editArea[fieldName].inputBox.value = obj[fieldName];
            }
        }

    }; // writeErrorObjToUI

    // write "" (empty string) to all inputs. 
    editArea.blankInputs = function () {

        console.log("Blanking inputs in the edit area.");

        for (var i = 0; i < fieldDefn.length; i++) {
            var fieldName = fieldDefn[i].fieldName;

            // pickLists (FK fields) do not have an input box, so skip them.
            if (editArea[fieldName].inputBox) {
                editArea[fieldName].inputBox.value = "";
            }
        }
    }; // blankInputs

    return editArea;
}//MakeEditArea

(function () {  // This is an IIFE, an immediately executing function.
    // It is an anonymous function that runs once (and only once) at page load time.
    // Put in here any private functions to be shared (e.g., by productMods.insert 
    // and productMods.update). 

    //alert("I am an IIFE!"); // runs only at page load time...

    // All variables declared in this area (before productMods.insert) 
    // will be avilable to productMods.insert AND productMods.update 
    // (once we get to that module). 


    var fields = [
        {
            fieldName: "productId",
            prompt: "Product Id",
            disabled: true
        },
//        {
//            fieldName: "userEmail"
//            //prompt: "Email"  // if you forget to add the prompt, it uses the field name as prompt
//        },
        {
            fieldName: "productName",
            prompt: "Product Name"
            
        },
        
        {
            fieldName: "image",
            prompt: "Image URL"
        },

        {
            fieldName: "price",
            prompt: "Price"
        },
        {
            fieldName: "stock",
            prompt: "Stock"
            
        },
        {
            fieldName: "webUserId",
            prompt: "Web User",
            pickList: true
        }
    ];

    var component = document.createElement("div");

    // call reusable function to make an edit area component
    var userEditArea = MakeEditArea({
        areaTitle: "Will Get Changed...",
        fieldDefn: fields
    });
    component.appendChild(userEditArea);



    productMods.insert = function () {

        // Create UI for insert (using the shared DOM elements just above, in the IIFE).
        userEditArea.areaTitle.innerHTML = "New Product";
        userEditArea.blankInputs();
        userEditArea.button.innerHTML = "Submit";
        userEditArea.formMsg.innerHTML = ""; // wipe out any old message

        // *********************************************************
        // Add web user pick list to userEditArea (the webUserId row of the HTML table). 
        // I wanted to show how you could get fresh list of user Ids from the DB 
        // with each user insert since you'll need to do something like this for 
        // insert "other" (get a fresh copy of users for the webuser FK from "other"). 
        ajax("webAPIs/listUsersAPI.jsp", processUsers, userEditArea.formMsg);

        function processUsers(obj) {
            // obj is the list of web user Id returned by the listUsersAPI.jsp
            if (obj.dbError.length > 0) {
                userEditArea["webUserId"].errorTd.innerHTML +=
                        "Programmer Error: Cannot Create User Pick List... " +
                        obj.dbError;
            } else {
                var selectTag = Utils.makePickList({
                    list: obj.webUserList,
                    idProp: "webUserId",
                    displayProp: "webUserId"
                });

                // put the Role select tag (just made) into the inputTd property 
                // of the UserRoleId row of the HTML table 
                userEditArea["webUserId"].inputTd.innerHTML = "";
                userEditArea["webUserId"].inputTd.appendChild(selectTag);
            }
        } // processUsers (ajax call back function 
        // *********************************************************

        userEditArea.button.onclick = function () {  // INSERT SAVE

            // inputObj is an object with all user input values. 
            var userInputObj = userEditArea.getDataFromUI();

            // Place the web user (selected option of the select tag) into the userInputObj
            var userSelect = userEditArea["webUserId"].inputTd.getElementsByTagName("select")[0];
            userInputObj.webUserId = userSelect.options[userSelect.selectedIndex].value;

            // convert userInputObj to JSON and URL encode (e.g., turns space to %20), 
            // URL encode so that the server does not reject URL for security reasons.
            var urlParams = encodeURIComponent(JSON.stringify(userInputObj));
            console.log("Insert Save URL params: " + urlParams);

            ajax("webAPIs/insertOtherAPI.jsp?jsonData=" + urlParams, reportInsert, userEditArea.formMsg);

            function reportInsert(obj) {

                // obj is the error message object (passed back from the Insert API).
                // obj (conveniently) has its fields named exactly the same as the input data was named. 

                console.log("Insert API response (error message object) on next line");
                console.log(obj);

                // write all the error messages to the UI (into the third column for each row).
                userEditArea.writeErrorObjToUI(obj);

                if (obj.errorMsg.length === 0) { // success
                    userEditArea.formMsg.innerHTML = "Record successfully inserted.";
                } else {
                    userEditArea.formMsg.innerHTML = obj.errorMsg;
                }
            }
        };

        return component;
    }; // productMods.insert
    
    productMods.update = function (productId) {
        userEditArea.areaTitle.innerHTML = "Update Product";
        userEditArea.blankInputs();
        userEditArea.button.innerHTML = "Update Save";
        userEditArea.formMsg.innerHTML = ""; // wipe out any old message

        console.log("productMods.update called with productId " + productId);

        // get the product record with the given productId
        ajax("webAPIs/getProductByIdAPI.jsp?productId=" + productId, gotRecordById, userEditArea.formMsg);

        // productObj is the output of getProductByIdAPI.jsp
        function gotRecordById(productObj) {

            userEditArea.writeDbValuesToUI(productObj);

            // get an updated list of roles (even though this does not change often), 
            // just so you see how to get a fresh role list with each web user insert.
            ajax("webAPIs/listUsersAPI.jsp", processUsers, userEditArea.formMsg);

            // obj is the output from getRolesAPI.jsp
            function processUsers(obj) {

                if (obj.dbError.length > 0) {
                    userEditArea["webUserId"].errorTd.innerHTML += "Programmer Error: Cannot Create User Pick List";
                } else {
                    console.log("web User Id is " + productObj.webUserId);
                    var selectTag = Utils.makePickList({
                        list: obj.webUserList,
                        idProp: "webUserId",
                        displayProp: "webUserId",
                        selectedKey: productObj.webUserId // key that is to be pre-selected (optional)
                    });

                    // Put the User Role Select Tag (just created) into the input column of the 
                    // userRoleId row of the HTML table we're using for data entry.
                    userEditArea["webUserId"].inputTd.innerHTML = "";
                    userEditArea["webUserId"].inputTd.appendChild(selectTag);
                }
            } // processUsers
        } // gotRecordById


        userEditArea.button.onclick = function () { // Update Save

            // collect all the user input values into an object. 
            var userInputObj = userEditArea.getDataFromUI();

            // find the user role selected from the select tag (and put it into userInputObj).
            var userSelect = userEditArea["webUserId"].inputTd.getElementsByTagName("select")[0];
            userInputObj.webUserId = userSelect.options[userSelect.selectedIndex].value;

            // convert userInputObj to JSON and URL encode (turns space to %20), 
            // so server does not reject URL for security reasons.
            var urlParams = encodeURIComponent(JSON.stringify(userInputObj));
            console.log("Update Save URL params: " + urlParams);

            ajax("webAPIs/updateProductAPI.jsp?jsonData=" + urlParams, reportUpdate, userEditArea.formMsg);

            function reportUpdate(jsErrorObj) {

                userEditArea.writeErrorObjToUI(jsErrorObj);

                // jsErrorObj is a StringData object full of error messages 
                // (using same field names). 

                if (jsErrorObj.errorMsg.length === 0) { // success
                    userEditArea.formMsg.innerHTML = "Record successfully updated. ";
                } else {
                    userEditArea.formMsg.innerHTML = jsErrorObj.errorMsg;
                }
            }
        }; //updateSave submit button

        return component;
    };//productMods.update

    function privateSharableFunctions ()
    {
        
    }
}());  // end of the IIFE